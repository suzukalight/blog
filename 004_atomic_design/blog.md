# Atomic Designを運用してみて

こんにちは。RELATIONS株式会社の久原です。

昨今、「Atomic Designを取り入れた」という記事も多く見かけるようになりました。弊社でもフロントエンド開発に様々な問題を抱えており、それを解消する目的でAtomic Designを取り入れましたので、その振り返りを行っていこうという記事になります。

# 運用前の問題

弊社ではReactにてUIコンポーネントを作成していますが、Atomic Designを運用する前は、コンポーネントの統一的指針がなかったがための、下記のような問題が発生していました；

1. コンポーネントの粒度がバラバラ
    - 超巨大なモノリシックコンポーネント
        - 500行のタイムラインコンポーネントとか
    - 直接Storeを見に行っているが、別にprops渡しでも大丈夫そうなコンポーネント
        - 状態管理について他者に依存している
        - 別のコンポーネントの一部として取り込まれることを、まるで意識していない
    - つまり、__責任分界点が曖昧__
2. 特定の機能を充足することに目が行き過ぎ
    - 似たような別のコンポーネントを作りがち
        - ほとんど同じふるまいのコンポーネントが3個目
        - 上流のコンポーネントが違うから
    - 前提となるコンポーネントが多い、ハイパー密結合なコンポーネントが数多く爆誕
        - StoreからもPrposからもStateからも、節操なく情報を取得する
        - 
    - つまり、コンポーネントは、__特定のビューに密結合しており、流用することができていない。__
3. コンポーネントのテストが存在しない
    - そもそもテスタビリティを考慮していない
        - クラスコンポーネント、変換ロジック、Presenterなどが未分離
    - テストの習慣がないので、テスタビリティのないロジックが散見
        - `Date.now()` に依存しているとか
    - すぐデグレる
        - 特にスタイル
    - つまり、__そもそもテストを受け入れることができない__

あるあるかもしれませんが、非常にお恥ずかしい…。事業のスピード感として、完璧より完成を目指していたこともありますが、それにしても節操なさすぎでした。

ありがたいことに実装担当者も増えてきたのですが、現在のところ設計指針となるドキュメントがない。みんなが好き勝手に作り出す前に、指針をつくるべき…。そんな思いもあって、今回Atomic Designを中心としたコンポーネント設計指針をまとめるに至りました。

# Atomic Designを用いた運用方針

Atomic Designそのものについての説明は省かせていただきます。

Atomic Designはデザイン周りの設計指針となりますので、基本的にはエンジニアチームとデザインチームとの連携が鍵となってきます。ただ新しい施策を導入する際は、小さく始めることが肝要だとも考えており、__今回はエンジニアチーム向けのコンポーネントガイドラインとして限定利用します__。デザイナを巻き込むのは次の段階でチャレンジ。

現状の問題点を踏まえて、以下の問題を解消できることを目的としました；

1. 責任分界点を明確化する
2. 流用可能性を上げること
3. コンポーネントテスタビリティを向上させること

## 責任分界点

Atomic Designには5つのレイヤが存在し、その振り分けがしばしば議論になります。今回はエンジニア視点でのADを考えます。フロントエンド実装者としての関心事から考えたとき、状態管理の基準が、レイヤー分けの基準になりました；

| layer     | 状態管理／粒度 |
|-----------|---------|
| ~~templates~~ | ~~使用しない。SPAなのてテンプレートは基本1つのため~~ |
| pages     | URL情報に直接アクセスできる |
| organisms | Storeにconnectできる・APIコールできる |
| molecules | 「ユーザに対して有意な情報」を表示できる粒度（Objectくらい） |
| atoms     | デザインの乗ったpやinput要素くらいの感じ、使い回しが「前提」 |

### pages

> ex.ホーム画面

1. URLの更新に対する責任を持つ
2. 子organismsに対し、どのエンティティを表示すべきかの指示を行う
3. 大枠のレイアウトを行う

__pagesはURLの更新に対する責任を持つ層です__。SPAにおけるルーティング層になります。React-RouterのSwitch+Routeをexportするコンポーネントを想定します。

```
// routing.js

export const Home = () => (
  <Switch>
    <Route path={Url.home.index} component={HomeRoot} />
    ...
  </Switch>
);
```

URLが変更された場合、pagesはcomponentDidUpdateなどでその検知を行い、必要に応じてAPIをコールし直して、新しい画面に必要な情報を取得します。このため fetch API を呼ぶアクションが最も多く配備されます。

もうひとつの役割は、子コンポーネントへpropsとしてURL情報をパースして与えることです。__つまり子コンポーネントがどのエンティティに関する情報を表示すべきかの指示を与えます__。そうして

```
<div className="pHome">
  <div className="pHome__stats">
    <Stats userId={userId} />
  </div>
  <div className="pHome__objectives">
    <Objectives userId={userId} />
  </div>
  ...
</div>
```

ちょっとしたテクニックとしては、この単位でcode-splittingすることで、初回ローディングの負荷を減らすことができるようになります。

### organisms

> ex.コメント欄

Storeにアクセスできる層です。

pages層からエンティティIDなどを指示されることで、必要な情報をStoreから拾い上げ、表示可能な情報へと変換し、子コンポーネントにpropsとして渡すレイヤとして考えます。なのでselectorが一番発達している層です。

```
createStructuredSelector
```

もうひとつの役割は、APIにアクセスし、エンティティの更新を行うことです。この層が最も多くのhandleメソッドを持ちます。

```
class Timeline {
    handlePostNode = values => { this.props.nodeActions.postTextPost(values); }

    render() {
        ...
        <TextForm onSubmit={this.handlePostNode} />
    }
}
```

全体的に、エンティティへの操作を考える

### molecules

> ex.コメントノード

エンティティの全部または一部を、実際にレンダリングする層です。ユーザにとって意味のある情報の集合体であることを想定しています。

```
```

デザイン要素としてのatomsや、UIパーツとしてのatomsなど、atomsを組み合わせて組み立てていくことが期待されます。そうすることでデザインの統一性を担保しやすくなると思います。

### atoms

> ex.UIパーツ（アバター・テキストインプット・ボタン）

ユーザとのインタラクションの1つを表現する層です。この層は、エンティティを自身で解釈することはなく、propsで渡された情報をもとに、HTML要素と連結することに重点を置いています。

- 編集ギアメニュー
- アバター

1つの機能部品として、独立した表示状態を提供することが多いため、this.stateで自身の表示状態を管理することも多いです。このstateはアプリのエンティティと紐付かない限りは、自由に作成できます。

```
class Accordion extends React.Component {
    state = { show: false };

    handleToggle = () => { this.setState(prev => ({ ...prev, show: !prev.show }))}
}
```

## 流用可能性

- propsにのみ依存させる
    - Storeに依存させると、流用性がなくなる
- 揮発的な表示変更は、Reduxを通さず、this.stateを使う
    - アプリの状態には影響しないため
- デザインも、上位のコンポーネントがw/h/margin/positionを規定する
    - 自身はborder領域まで。paddingなどは自身の管轄内であり、規定してよい
    - 

## テスタビリティ

- storybook：目視テスト
    - パターンだしを行うこと
    - コード例
- storyshots：デグレテスト
    - コード例
- jest：ロジックテスト
    - レンダリングと変換ロジックを分離コーディング
    - コード例
- (WIP) puppeteer：E2Eテスト
- (WIP) image-snap：visual regression testing

# 結果

コンポーネントの責任分界点が確立できたことにより、明確な分業を体制化できました。

- molecules層とorganisms層での並列作業が可能に
    - settingsで実現
    - 見た目を作り込む担当と、ロジックを作り込む担当が分かれる感じで動けた
- JSXとpropsだけ先に記述し、マークアップとロジックを並列作業可能に
    - timelineで実現
    - storybookでマークアップを完結でき、ローカルサーバが不要に

# 課題

現在のWistantは、上記の指針に則って開発を進めています。初めてから半年ほどが経過し、新たな課題も見えてきました；

- これってデザイン観点でのAtomic Designとは違うのでは？
    - 違うと思う
        - エンジニア視点から始めたので、それはそう
    - molecules/organismsあたりの切り分け基準は、ロジック的な観点が大きい
        - デザイナと協働するときに、そこのすり合わせは必要だと思う
- atomにformパーツが集中
    - 理屈上そうなる
    - 見通しが悪くなってきたため、_formsのサブディレクトリを切ってしまう羽目に
        - 弊社だとredux-form前提なので、forms配下はredux-form前提コンポーネントですよ、と表明したかったのもある
- atoms/moleculesの境界あいまい問題
    - よく私が指摘される
        - コンテンツヘッダはatoms
        - moleculesは、atomを組み合わせた時点で、デザイン観点からはmolecules一択だが…
- organismsに過剰分割しがち
    - pagesがただのrouting層なので
    - organismsを水平管理すると、コンポーネントが100個とかできる
        - 垂直管理するか、使い回さないならpagesに置くべき
        - 使い回さないコンポーネントは、無理にexportしない
- 使い回さないコンポーネントの位置
    - 使い回さないのに、共通moleculesディレクトリに入っている
        - 使い回さないなら、その親コンポーネントの配下で良いのでは？
        - 「使い回すコンポーネント」置き場としての、 `/molecules` とかが望ましいと考えている
- storyshotsのデグレテストが疎かになりがち
    - スタイルのデグレチェックができていないので、効果が半減
        - cssもsnapshotに含んでしまってテストしてもよいのでは

# 今後の展開

- デザインシステムの構築を開始
    - デザイナがADを学習してくれて、デザインシステムにADを採用してくれた
    - デザインとコンポーネントが1:1につながる世界を目指す
    - 特にatomsについて、デザインシステムで管理していく
    - フロントエンド観点からのAtomic Designになっているので、デザイナとすり合せていく
- E2Eテストの検討
    - 機能レベルでのテストができていない
    - enzymeも特に使っていない

-----

- container/presenterが便利
    - propsだけでstoryかけるようにした
    - organismsもstoryかける
- template？
    - 世間のadは、layoutとしてのテンプレートがある
    - pagesだけがconnectするように…できる？
    - MPAならあるけど
- デザインシステムとつなげていくべき
    - wistantのみのスタイリングになっている
    - variants的な感じで
        - andlearnとか別のプロダクトにも
        - 使えないときがもったいない！Atomsとか